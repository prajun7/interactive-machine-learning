<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Kernel Method Visualization</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .container {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        max-width: 1400px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .back-link {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #4299e1;
        text-decoration: none;
        font-weight: bold;
        padding: 10px 15px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.9);
        transition: all 0.3s ease;
      }

      .back-link:hover {
        background: #4299e1;
        color: white;
      }

      .title {
        color: #2d3748;
        font-size: 32px;
        font-weight: bold;
        margin-bottom: 10px;
      }

      .subtitle {
        color: #718096;
        font-size: 18px;
        margin-bottom: 20px;
      }

      .visualization-container {
        display: flex;
        gap: 30px;
        margin-bottom: 30px;
        align-items: flex-start;
      }

      .plot-section {
        flex: 1;
        background: #f8f9fa;
        border: 2px solid #e2e8f0;
        border-radius: 15px;
        padding: 20px;
        text-align: center;
      }

      .plot-title {
        font-size: 20px;
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 15px;
      }

      .plot-area {
        background: white;
        border: 1px solid #cbd5e0;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 15px;
        position: relative;
      }

      .controls {
        background: #f0f8ff;
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #4299e1;
        margin-bottom: 20px;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-label {
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 8px;
        display: block;
      }

      .slider-container {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      input[type="range"] {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: #e2e8f0;
        outline: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4299e1;
        cursor: pointer;
      }

      .value-display {
        background: #4299e1;
        color: white;
        padding: 5px 12px;
        border-radius: 15px;
        font-weight: bold;
        min-width: 60px;
        text-align: center;
      }

      .explanation {
        background: #e6fffa;
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #81e6d9;
        margin: 20px 0;
      }

      .explanation h3 {
        color: #2d3748;
        margin-bottom: 15px;
      }

      .explanation p {
        color: #4a5568;
        line-height: 1.6;
        margin-bottom: 10px;
      }

      .key-insight {
        background: #fff3cd;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #ffc107;
        margin: 15px 0;
      }

      .key-insight strong {
        color: #856404;
      }

      .transformation-steps {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .step {
        background: #f0f4f8;
        padding: 20px;
        border-radius: 10px;
        border-top: 5px solid #4299e1;
        text-align: center;
      }

      .step-number {
        background: #4299e1;
        color: white;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-bottom: 15px;
      }

      .step h4 {
        color: #2d3748;
        margin-bottom: 10px;
      }

      .step p {
        color: #4a5568;
        font-size: 14px;
        line-height: 1.5;
      }

      .data-point {
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .data-point:hover {
        r: 8;
      }

      .star-point {
        fill: #e53e3e;
        stroke: #c53030;
        stroke-width: 2;
      }

      .plus-point {
        fill: #3182ce;
        stroke: #2c5282;
        stroke-width: 2;
      }

      .decision-boundary {
        stroke: #38a169;
        stroke-width: 3;
        stroke-dasharray: 5, 5;
        opacity: 0.8;
      }

      .transformation-line {
        stroke: #f56565;
        stroke-width: 2;
        stroke-dasharray: 3, 3;
        opacity: 0.7;
      }

      .axis-label {
        font-size: 14px;
        font-weight: bold;
        fill: #4a5568;
      }

      .grid-line {
        stroke: #e2e8f0;
        stroke-width: 1;
      }

      .legend {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 15px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #4a5568;
      }

      .legend-symbol {
        width: 16px;
        height: 16px;
        border-radius: 50%;
      }

      .legend-star {
        background: #e53e3e;
        border: 2px solid #c53030;
      }

      .legend-plus {
        background: #3182ce;
        border: 2px solid #2c5282;
      }

      .animation-controls {
        text-align: center;
        margin: 20px 0;
      }

      .btn {
        background: #4299e1;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        margin: 0 10px;
        transition: all 0.3s ease;
      }

      .btn:hover {
        background: #3182ce;
        transform: translateY(-2px);
      }

      .btn:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
        transform: none;
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-link">‚Üê Back to Interactive ML</a>

    <div class="container">
      <div class="header">
        <h1 class="title">Interactive Kernel Method Visualization</h1>
        <p class="subtitle">
          Understanding the Kernel Trick: From 2D to Higher Dimensions
        </p>
      </div>

      <div class="explanation">
        <h3>üéØ The Kernel Trick Explained</h3>
        <p>
          The kernel trick is a powerful technique that allows us to work with
          data that is not linearly separable in the original space by
          implicitly mapping it to a higher-dimensional space where it becomes
          linearly separable.
        </p>

        <div class="key-insight">
          <strong>üí° Key Insight:</strong> Instead of explicitly computing the
          coordinates in the higher-dimensional space, we use kernel functions
          to compute the inner products between the images of all pairs of data
          in the feature space.
        </div>
      </div>

      <div class="visualization-container">
        <div class="plot-section">
          <h3 class="plot-title">üìä Original 2D Space</h3>
          <div class="plot-area">
            <svg id="plot2d" width="400" height="400">
              <!-- Grid -->
              <defs>
                <pattern
                  id="grid2d"
                  width="40"
                  height="40"
                  patternUnits="userSpaceOnUse"
                >
                  <path
                    d="M 40 0 L 0 0 0 40"
                    fill="none"
                    stroke="#e2e8f0"
                    stroke-width="1"
                  />
                </pattern>
              </defs>
              <rect width="100%" height="100%" fill="url(#grid2d)" />

              <!-- Axes -->
              <line
                x1="40"
                y1="360"
                x2="360"
                y2="360"
                stroke="#4a5568"
                stroke-width="2"
              />
              <line
                x1="40"
                y1="360"
                x2="40"
                y2="40"
                stroke="#4a5568"
                stroke-width="2"
              />

              <!-- Axis labels -->
              <text x="200" y="390" text-anchor="middle" class="axis-label">
                Feature X‚ÇÅ
              </text>
              <text
                x="15"
                y="200"
                text-anchor="middle"
                class="axis-label"
                transform="rotate(-90, 15, 200)"
              >
                Feature X‚ÇÇ
              </text>

              <!-- Data points will be added here -->
              <g id="data-points-2d"></g>

              <!-- Decision boundary -->
              <g id="decision-boundary-2d"></g>
            </svg>
          </div>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-symbol legend-star"></div>
              <span>Class A (Stars)</span>
            </div>
            <div class="legend-item">
              <div class="legend-symbol legend-plus"></div>
              <span>Class B (Plus)</span>
            </div>
          </div>
        </div>

        <div class="plot-section">
          <h3 class="plot-title">üöÄ Transformed 3D Space</h3>
          <div class="plot-area">
            <svg id="plot3d" width="400" height="400">
              <!-- Grid -->
              <defs>
                <pattern
                  id="grid3d"
                  width="40"
                  height="40"
                  patternUnits="userSpaceOnUse"
                >
                  <path
                    d="M 40 0 L 0 0 0 40"
                    fill="none"
                    stroke="#e2e8f0"
                    stroke-width="1"
                  />
                </pattern>
              </defs>
              <rect width="100%" height="100%" fill="url(#grid3d)" />

              <!-- Axes -->
              <line
                x1="40"
                y1="360"
                x2="360"
                y2="360"
                stroke="#4a5568"
                stroke-width="2"
              />
              <line
                x1="40"
                y1="360"
                x2="40"
                y2="40"
                stroke="#4a5568"
                stroke-width="2"
              />

              <!-- Axis labels -->
              <text x="200" y="390" text-anchor="middle" class="axis-label">
                Feature X‚ÇÅ
              </text>
              <text
                x="15"
                y="200"
                text-anchor="middle"
                class="axis-label"
                transform="rotate(-90, 15, 200)"
              >
                Feature X‚ÇÇ
              </text>
              <text x="200" y="15" text-anchor="middle" class="axis-label">
                Feature X‚ÇÉ (Kernel)
              </text>

              <!-- Data points will be added here -->
              <g id="data-points-3d"></g>

              <!-- Decision boundary -->
              <g id="decision-boundary-3d"></g>

              <!-- Transformation lines -->
              <g id="transformation-lines"></g>
            </svg>
          </div>
          <div class="legend">
            <div class="legend-item">
              <div class="legend-symbol legend-star"></div>
              <span>Class A (Stars)</span>
            </div>
            <div class="legend-item">
              <div class="legend-symbol legend-plus"></div>
              <span>Class B (Plus)</span>
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <h3>‚öôÔ∏è Interactive Controls</h3>
        <div class="control-group">
          <label class="control-label">üéØ Kernel Width (œÉ):</label>
          <div class="slider-container">
            <input
              type="range"
              id="kernelWidth"
              min="0.5"
              max="3"
              step="0.1"
              value="1.5"
            />
            <span class="value-display" id="kernelWidthValue">1.5</span>
          </div>
          <small style="color: #666"
            >Controls how much influence each point has on the
            transformation</small
          >
        </div>

        <div class="control-group">
          <label class="control-label">üìê Transformation Strength:</label>
          <div class="slider-container">
            <input
              type="range"
              id="transformStrength"
              min="0"
              max="1"
              step="0.1"
              value="0"
            />
            <span class="value-display" id="transformStrengthValue">0.0</span>
          </div>
          <small style="color: #666"
            >Shows the gradual transformation from 2D to 3D space</small
          >
        </div>
      </div>

      <div class="animation-controls">
        <button class="btn" id="animateBtn">üé¨ Animate Transformation</button>
        <button class="btn" id="resetBtn">üîÑ Reset</button>
      </div>

      <div class="transformation-steps">
        <div class="step">
          <div class="step-number">1</div>
          <h4>Original Problem</h4>
          <p>
            Data points are arranged in a circular pattern where stars are in
            the center and plus signs surround them. No straight line can
            separate these classes in 2D.
          </p>
        </div>
        <div class="step">
          <div class="step-number">2</div>
          <h4>Kernel Function</h4>
          <p>
            We apply a radial basis function (RBF) kernel: K(x,y) =
            exp(-||x-y||¬≤/2œÉ¬≤). This maps points to a higher-dimensional space.
          </p>
        </div>
        <div class="step">
          <div class="step-number">3</div>
          <h4>Higher Dimension</h4>
          <p>
            In the transformed space, the stars "lift up" while the plus signs
            stay lower, creating a clear separation that can be achieved with a
            linear boundary.
          </p>
        </div>
        <div class="step">
          <div class="step-number">4</div>
          <h4>Linear Separation</h4>
          <p>
            A simple plane can now separate the two classes, demonstrating how
            the kernel trick makes non-linear problems linear in higher
            dimensions.
          </p>
        </div>
      </div>

      <div class="explanation">
        <h3>üßÆ Mathematical Details</h3>
        <p><strong>RBF Kernel:</strong> K(x,y) = exp(-||x-y||¬≤/2œÉ¬≤)</p>
        <p>
          <strong>Transformation:</strong> œÜ(x) = [x‚ÇÅ, x‚ÇÇ, exp(-||x||¬≤/2œÉ¬≤)]
        </p>
        <p>
          <strong>Effect:</strong> Points closer to the origin get "lifted" more
          in the third dimension, creating the separation needed for linear
          classification.
        </p>
      </div>
    </div>

    <script>
      // Data points: stars in center, plus signs around
      const starPoints = [
        { x: 200, y: 200, label: "star" },
        { x: 180, y: 220, label: "star" },
        { x: 220, y: 180, label: "star" },
        { x: 190, y: 190, label: "star" },
        { x: 210, y: 210, label: "star" },
      ];

      const plusPoints = [
        { x: 120, y: 120, label: "plus" },
        { x: 280, y: 120, label: "plus" },
        { x: 120, y: 280, label: "plus" },
        { x: 280, y: 280, label: "plus" },
        { x: 150, y: 150, label: "plus" },
        { x: 250, y: 150, label: "plus" },
        { x: 150, y: 250, label: "plus" },
        { x: 250, y: 250, label: "plus" },
        { x: 100, y: 200, label: "plus" },
        { x: 300, y: 200, label: "plus" },
        { x: 200, y: 100, label: "plus" },
        { x: 200, y: 300, label: "plus" },
      ];

      const allPoints = [...starPoints, ...plusPoints];

      // RBF Kernel function
      function rbfKernel(x, y, sigma) {
        const distance = Math.sqrt((x.x - y.x) ** 2 + (x.y - y.y) ** 2);
        return Math.exp(-(distance ** 2) / (2 * sigma ** 2));
      }

      // Transform point to 3D
      function transformTo3D(point, sigma, strength) {
        const distanceFromOrigin = Math.sqrt(point.x ** 2 + point.y ** 2);
        const z = Math.exp(-(distanceFromOrigin ** 2) / (2 * sigma ** 2));

        // Interpolate between original and transformed position
        const originalZ = 0;
        const transformedZ = z * 200; // Scale for visualization

        const finalZ = originalZ + (transformedZ - originalZ) * strength;

        return {
          x: point.x,
          y: point.y,
          z: finalZ,
          label: point.label,
        };
      }

      // Draw data points
      function drawPoints(svgId, points, is3D = false) {
        const svg = document.getElementById(svgId);
        const pointsGroup = svg.querySelector(
          `#data-points-${is3D ? "3d" : "2d"}`
        );
        pointsGroup.innerHTML = "";

        points.forEach((point) => {
          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", point.x);
          circle.setAttribute("cy", is3D ? point.y - point.z * 0.3 : point.y); // Adjust Y for 3D effect
          circle.setAttribute("r", 6);
          circle.setAttribute("class", `data-point ${point.label}-point`);

          // Add hover effect
          circle.addEventListener("mouseenter", () => {
            circle.setAttribute("r", 8);
          });
          circle.addEventListener("mouseleave", () => {
            circle.setAttribute("r", 6);
          });

          pointsGroup.appendChild(circle);
        });
      }

      // Draw decision boundaries
      function drawDecisionBoundaries() {
        // 2D decision boundary (circular)
        const svg2d = document.getElementById("plot2d");
        const boundary2d = svg2d.querySelector("#decision-boundary-2d");
        boundary2d.innerHTML = "";

        const centerX = 200,
          centerY = 200,
          radius = 80;
        const circle = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        circle.setAttribute("cx", centerX);
        circle.setAttribute("cy", centerY);
        circle.setAttribute("r", radius);
        circle.setAttribute("class", "decision-boundary");
        circle.setAttribute("fill", "none");
        boundary2d.appendChild(circle);

        // 3D decision boundary (plane)
        const svg3d = document.getElementById("plot3d");
        const boundary3d = svg3d.querySelector("#decision-boundary-3d");
        boundary3d.innerHTML = "";

        // Draw a horizontal line representing the separating plane
        const line = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        );
        line.setAttribute("x1", 40);
        line.setAttribute("y1", 280);
        line.setAttribute("x2", 360);
        line.setAttribute("y2", 280);
        line.setAttribute("class", "decision-boundary");
        boundary3d.appendChild(line);
      }

      // Draw transformation lines
      function drawTransformationLines(strength) {
        const svg3d = document.getElementById("plot3d");
        const linesGroup = svg3d.querySelector("#transformation-lines");
        linesGroup.innerHTML = "";

        if (strength > 0) {
          allPoints.forEach((point) => {
            const originalY = point.y;
            const transformedPoint = transformTo3D(
              point,
              parseFloat(document.getElementById("kernelWidth").value),
              strength
            );
            const finalY = transformedPoint.y - transformedPoint.z * 0.3;

            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            line.setAttribute("x1", point.x);
            line.setAttribute("y1", originalY);
            line.setAttribute("x2", point.x);
            line.setAttribute("y2", finalY);
            line.setAttribute("class", "transformation-line");
            linesGroup.appendChild(line);
          });
        }
      }

      // Update visualization
      function updateVisualization() {
        const kernelWidth = parseFloat(
          document.getElementById("kernelWidth").value
        );
        const transformStrength = parseFloat(
          document.getElementById("transformStrength").value
        );

        // Update 2D plot
        drawPoints("plot2d", allPoints, false);

        // Update 3D plot
        const transformedPoints = allPoints.map((point) =>
          transformTo3D(point, kernelWidth, transformStrength)
        );
        drawPoints("plot3d", transformedPoints, true);

        // Update decision boundaries
        drawDecisionBoundaries();

        // Update transformation lines
        drawTransformationLines(transformStrength);
      }

      // Animation
      let animationId = null;
      let animationDirection = 1;
      let animationProgress = 0;

      function animate() {
        animationProgress += 0.02 * animationDirection;

        if (animationProgress >= 1) {
          animationDirection = -1;
          animationProgress = 1;
        } else if (animationProgress <= 0) {
          animationDirection = 1;
          animationProgress = 0;
        }

        document.getElementById("transformStrength").value = animationProgress;
        document.getElementById("transformStrengthValue").textContent =
          animationProgress.toFixed(1);
        updateVisualization();

        animationId = requestAnimationFrame(animate);
      }

      // Event listeners
      document
        .getElementById("kernelWidth")
        .addEventListener("input", function () {
          document.getElementById("kernelWidthValue").textContent = this.value;
          updateVisualization();
        });

      document
        .getElementById("transformStrength")
        .addEventListener("input", function () {
          document.getElementById("transformStrengthValue").textContent =
            this.value;
          updateVisualization();
        });

      document
        .getElementById("animateBtn")
        .addEventListener("click", function () {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
            this.textContent = "üé¨ Animate Transformation";
          } else {
            animate();
            this.textContent = "‚è∏Ô∏è Stop Animation";
          }
        });

      document
        .getElementById("resetBtn")
        .addEventListener("click", function () {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
            document.getElementById("animateBtn").textContent =
              "üé¨ Animate Transformation";
          }

          document.getElementById("transformStrength").value = 0;
          document.getElementById("transformStrengthValue").textContent = "0.0";
          animationProgress = 0;
          animationDirection = 1;
          updateVisualization();
        });

      // Initialize
      updateVisualization();
    </script>
  </body>
</html>
