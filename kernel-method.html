<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Kernel Method Visualization</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .container {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        max-width: 1600px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .title {
        color: #2d3748;
        font-size: 32px;
        font-weight: bold;
        margin-bottom: 10px;
      }

      .subtitle {
        color: #718096;
        font-size: 18px;
        margin-bottom: 20px;
      }

      .visualization-container {
        display: flex;
        gap: 30px;
        margin-bottom: 30px;
        align-items: flex-start;
      }

      .plot-section {
        flex: 1;
        background: #f8f9fa;
        border: 2px solid #e2e8f0;
        border-radius: 15px;
        padding: 20px;
        text-align: center;
      }

      .plot-title {
        font-size: 20px;
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 15px;
      }

      .plot-area {
        background: white;
        border: 1px solid #cbd5e0;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 15px;
        position: relative;
      }

      .controls {
        background: #f0f8ff;
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #4299e1;
        margin-bottom: 20px;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-label {
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 8px;
        display: block;
      }

      .slider-container {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      input[type="range"] {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: #e2e8f0;
        outline: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4299e1;
        cursor: pointer;
      }

      .value-display {
        background: #4299e1;
        color: white;
        padding: 5px 12px;
        border-radius: 15px;
        font-weight: bold;
        min-width: 60px;
        text-align: center;
      }

      .btn {
        background: #4299e1;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        margin: 0 10px;
        transition: all 0.3s ease;
      }

      .btn:hover {
        background: #3182ce;
        transform: translateY(-2px);
      }

      .btn:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
        transform: none;
      }

      .red-point {
        fill: #e53e3e;
        stroke: #c53030;
        stroke-width: 2;
      }

      .blue-point {
        fill: #3182ce;
        stroke: #2c5282;
        stroke-width: 2;
      }

      .attempted-line {
        stroke: #ff6b6b;
        stroke-width: 3;
        opacity: 0.7;
      }

      .decision-plane {
        fill: rgba(56, 161, 105, 0.3);
        stroke: #38a169;
        stroke-width: 2;
      }

      .axis-label {
        font-size: 12px;
        font-weight: bold;
        fill: #4a5568;
      }

      .explanation {
        background: #e6fffa;
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #81e6d9;
        margin: 20px 0;
      }

      .explanation h3 {
        color: #2d3748;
        margin-bottom: 15px;
      }

      .explanation p {
        color: #4a5568;
        line-height: 1.6;
        margin-bottom: 10px;
      }

      .key-insight {
        background: #fff3cd;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #ffc107;
        margin: 15px 0;
      }

      .key-insight strong {
        color: #856404;
      }

      .legend {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 15px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #4a5568;
      }

      .legend-symbol {
        width: 16px;
        height: 16px;
        border-radius: 50%;
      }

      .legend-red {
        background: #e53e3e;
        border: 2px solid #c53030;
      }

      .legend-blue {
        background: #3182ce;
        border: 2px solid #2c5282;
      }

      .animation-controls {
        text-align: center;
        margin: 20px 0;
      }

      .status-text {
        font-weight: bold;
        margin-top: 10px;
        padding: 10px;
        border-radius: 8px;
      }

      .status-impossible {
        background: #fed7d7;
        color: #c53030;
      }

      .status-possible {
        background: #c6f6d5;
        color: #2f855a;
      }

      #canvas3d {
        border: 1px solid #cbd5e0;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div style="margin-bottom: 20px">
        <a
          href="index.html"
          style="
            text-decoration: none;
            color: #667eea;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
          "
        >
          ‚Üê Back to Interactive ML
        </a>
      </div>
      <div class="header">
        <h1 class="title">Enhanced Kernel Method Visualization</h1>
        <p class="subtitle">
          Understanding Why Linear Separation Fails in 2D but Succeeds in 3D
        </p>
      </div>

      <div class="explanation">
        <h3>üéØ The Kernel Method Problem</h3>
        <p>
          Some data patterns cannot be separated by any straight line in their
          original space. The kernel method solves this by mapping the data to a
          higher-dimensional space where linear separation becomes possible.
        </p>
      </div>

      <div class="visualization-container">
        <div class="plot-section">
          <h3 class="plot-title">‚ùå 2D Space - Linear Separation Impossible</h3>
          <div class="plot-area">
            <svg id="plot2d" width="400" height="400">
              <!-- Grid -->
              <defs>
                <pattern
                  id="grid2d"
                  width="20"
                  height="20"
                  patternUnits="userSpaceOnUse"
                >
                  <path
                    d="M 20 0 L 0 0 0 20"
                    fill="none"
                    stroke="#f0f0f0"
                    stroke-width="1"
                  />
                </pattern>
              </defs>
              <rect width="100%" height="100%" fill="url(#grid2d)" />

              <!-- Axes -->
              <line
                x1="40"
                y1="360"
                x2="360"
                y2="360"
                stroke="#4a5568"
                stroke-width="2"
              />
              <line
                x1="40"
                y1="360"
                x2="40"
                y2="40"
                stroke="#4a5568"
                stroke-width="2"
              />

              <!-- Axis labels -->
              <text x="200" y="390" text-anchor="middle" class="axis-label">
                x‚ÇÅ
              </text>
              <text
                x="15"
                y="200"
                text-anchor="middle"
                class="axis-label"
                transform="rotate(-90, 15, 200)"
              >
                x‚ÇÇ
              </text>

              <!-- Data points -->
              <g id="data-points-2d"></g>

              <!-- Attempted separation lines -->
              <g id="attempted-lines"></g>
            </svg>
          </div>
          <div class="status-text status-impossible" id="status-2d">
            No straight line can separate these classes!
          </div>
        </div>

        <div class="plot-section">
          <h3 class="plot-title">‚úÖ 3D Space - Linear Separation Possible</h3>
          <div class="plot-area">
            <canvas id="canvas3d" width="400" height="400"></canvas>
          </div>
          <div class="status-text status-possible" id="status-3d">
            A plane can easily separate the classes in 3D!
          </div>
        </div>
      </div>

      <div class="controls">
        <h3>‚öôÔ∏è Interactive Controls</h3>
        <div class="control-group">
          <label class="control-label">üéØ Kernel Parameter (œÉ):</label>
          <div class="slider-container">
            <input
              type="range"
              id="kernelSigma"
              min="10"
              max="80"
              step="5"
              value="40"
            />
            <span class="value-display" id="kernelSigmaValue">40</span>
          </div>
          <small style="color: #666"
            >Controls the width of the kernel transformation</small
          >
        </div>

        <div class="control-group">
          <label class="control-label">üîÑ 3D Rotation:</label>
          <div class="slider-container">
            <input
              type="range"
              id="rotation"
              min="0"
              max="360"
              step="5"
              value="45"
            />
            <span class="value-display" id="rotationValue">45¬∞</span>
          </div>
          <small style="color: #666"
            >Rotate the 3D view to see the separation better</small
          >
        </div>
      </div>

      <div class="animation-controls">
        <button class="btn" id="animateBtn">üé¨ Auto Rotate 3D View</button>
        <button class="btn" id="showSeparationBtn">
          ‚úÇÔ∏è Show/Hide Separating Plane
        </button>
        <button class="btn" id="resetBtn">üîÑ Reset View</button>
      </div>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-symbol legend-red"></div>
          <span>Class A (Inner Circle)</span>
        </div>
        <div class="legend-item">
          <div class="legend-symbol legend-blue"></div>
          <span>Class B (Outer Ring)</span>
        </div>
      </div>

      <div class="explanation">
        <h3>üßÆ What's Happening?</h3>
        <p>
          <strong>2D Problem:</strong> Red points form an inner circle, blue
          points form an outer ring. No straight line can separate them.
        </p>
        <p>
          <strong>Kernel Transformation:</strong> œÜ(x) = [x‚ÇÅ, x‚ÇÇ,
          exp(-||x||¬≤/2œÉ¬≤)]
        </p>
        <p>
          <strong>3D Solution:</strong> The kernel "lifts" points based on their
          distance from origin, creating a cone where classes can be separated
          by a plane.
        </p>

        <div class="key-insight">
          <strong>üí° Key Insight:</strong> The closer a point is to the origin,
          the higher it gets lifted in the 3D space, naturally separating the
          inner and outer groups.
        </div>
      </div>
    </div>

    <script>
      // Data points - concentric circles pattern
      const innerPoints = []; // Red points (inner circle)
      const outerPoints = []; // Blue points (outer ring)

      // Generate inner circle (red points)
      const innerRadius = 50;
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * 2 * Math.PI;
        const r = innerRadius + (Math.random() - 0.5) * 20;
        innerPoints.push({
          x: 200 + r * Math.cos(angle),
          y: 200 + r * Math.sin(angle),
          class: "red",
        });
      }

      // Generate outer ring (blue points)
      const outerRadius = 120;
      for (let i = 0; i < 20; i++) {
        const angle = (i / 20) * 2 * Math.PI;
        const r = outerRadius + (Math.random() - 0.5) * 30;
        outerPoints.push({
          x: 200 + r * Math.cos(angle),
          y: 200 + r * Math.sin(angle),
          class: "blue",
        });
      }

      const allPoints = [...innerPoints, ...outerPoints];

      // 3D Canvas setup
      const canvas = document.getElementById("canvas3d");
      const ctx = canvas.getContext("2d");
      let rotation = 45;
      let animationId = null;
      let showPlane = true;

      // RBF Kernel transformation
      function transformTo3D(point, sigma) {
        const distFromOrigin = Math.sqrt(
          (point.x - 200) ** 2 + (point.y - 200) ** 2
        );
        const z = 100 * Math.exp(-(distFromOrigin ** 2) / (2 * sigma ** 2));

        return {
          x: (point.x - 200) / 2, // Scale for 3D view
          y: (point.y - 200) / 2,
          z: z,
          class: point.class,
        };
      }

      // 3D to 2D projection
      function project3D(x, y, z, rotX, rotY) {
        // Rotate around Y axis
        const cosY = Math.cos(rotY);
        const sinY = Math.sin(rotY);
        const xRot = x * cosY + z * sinY;
        const zRot = -x * sinY + z * cosY;

        // Rotate around X axis
        const cosX = Math.cos(rotX);
        const sinX = Math.sin(rotX);
        const yRot = y * cosX - zRot * sinX;
        const zFinal = y * sinX + zRot * cosX;

        // Perspective projection
        const distance = 300;
        const scale = distance / (distance + zFinal);

        return {
          x: 200 + xRot * scale,
          y: 200 + yRot * scale,
          z: zFinal,
        };
      }

      // Draw 2D plot
      function draw2D() {
        const svg = document.getElementById("plot2d");
        const pointsGroup = document.getElementById("data-points-2d");
        const linesGroup = document.getElementById("attempted-lines");

        // Clear previous points
        pointsGroup.innerHTML = "";
        linesGroup.innerHTML = "";

        // Draw points
        allPoints.forEach((point) => {
          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", point.x);
          circle.setAttribute("cy", point.y);
          circle.setAttribute("r", 6);
          circle.setAttribute("class", `${point.class}-point`);
          pointsGroup.appendChild(circle);
        });

        // Draw some attempted separation lines to show impossibility
        const attemptedLines = [
          { x1: 40, y1: 100, x2: 360, y2: 300 },
          { x1: 40, y1: 300, x2: 360, y2: 100 },
          { x1: 200, y1: 40, x2: 200, y2: 360 },
          { x1: 40, y1: 200, x2: 360, y2: 200 },
        ];

        attemptedLines.forEach((line, i) => {
          const lineEl = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          lineEl.setAttribute("x1", line.x1);
          lineEl.setAttribute("y1", line.y1);
          lineEl.setAttribute("x2", line.x2);
          lineEl.setAttribute("y2", line.y2);
          lineEl.setAttribute("class", "attempted-line");
          lineEl.setAttribute("opacity", 0.3);
          linesGroup.appendChild(lineEl);
        });
      }

      // Draw 3D plot
      function draw3D() {
        const sigma = parseFloat(document.getElementById("kernelSigma").value);
        const rotAngle = (rotation * Math.PI) / 180;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Transform all points to 3D
        const points3D = allPoints.map((p) => {
          const transformed = transformTo3D(p, sigma);
          const projected = project3D(
            transformed.x,
            transformed.y,
            transformed.z,
            0.3,
            rotAngle
          );
          return {
            ...projected,
            class: transformed.class,
            z3d: transformed.z,
          };
        });

        // Sort by z-depth for proper rendering
        points3D.sort((a, b) => a.z - b.z);

        // Draw separating plane if enabled
        if (showPlane) {
          drawSeparatingPlane(rotAngle);
        }

        // Draw 3D axes
        draw3DAxes(rotAngle);

        // Draw points
        points3D.forEach((point) => {
          const size = 6 + point.z3d * 0.02; // Size based on height
          ctx.beginPath();
          ctx.arc(point.x, point.y, size, 0, 2 * Math.PI);
          ctx.fillStyle = point.class === "red" ? "#e53e3e" : "#3182ce";
          ctx.strokeStyle = point.class === "red" ? "#c53030" : "#2c5282";
          ctx.lineWidth = 2;
          ctx.fill();
          ctx.stroke();
        });
      }

      // Draw 3D axes
      function draw3DAxes(rotAngle) {
        const axisLength = 150;

        // X axis (red)
        const xEnd = project3D(axisLength, 0, 0, 0.3, rotAngle);
        ctx.strokeStyle = "#ff4444";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(200, 200);
        ctx.lineTo(xEnd.x, xEnd.y);
        ctx.stroke();

        // Y axis (green)
        const yEnd = project3D(0, axisLength, 0, 0.3, rotAngle);
        ctx.strokeStyle = "#44ff44";
        ctx.beginPath();
        ctx.moveTo(200, 200);
        ctx.lineTo(yEnd.x, yEnd.y);
        ctx.stroke();

        // Z axis (blue)
        const zEnd = project3D(0, 0, axisLength, 0.3, rotAngle);
        ctx.strokeStyle = "#4444ff";
        ctx.beginPath();
        ctx.moveTo(200, 200);
        ctx.lineTo(zEnd.x, zEnd.y);
        ctx.stroke();

        // Axis labels
        ctx.fillStyle = "#4a5568";
        ctx.font = "12px Arial";
        ctx.fillText("x‚ÇÅ", xEnd.x + 5, xEnd.y);
        ctx.fillText("x‚ÇÇ", yEnd.x + 5, yEnd.y);
        ctx.fillText("œÜ(x)", zEnd.x + 5, zEnd.y - 5);
      }

      // Draw separating plane
      function drawSeparatingPlane(rotAngle) {
        const planeHeight = 50; // Height where plane cuts through
        const size = 120;

        // Define plane corners
        const corners = [
          project3D(-size, -size, planeHeight, 0.3, rotAngle),
          project3D(size, -size, planeHeight, 0.3, rotAngle),
          project3D(size, size, planeHeight, 0.3, rotAngle),
          project3D(-size, size, planeHeight, 0.3, rotAngle),
        ];

        // Draw plane
        ctx.beginPath();
        ctx.moveTo(corners[0].x, corners[0].y);
        corners.forEach((corner) => ctx.lineTo(corner.x, corner.y));
        ctx.closePath();
        ctx.fillStyle = "rgba(56, 161, 105, 0.3)";
        ctx.fill();
        ctx.strokeStyle = "#38a169";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // Animation loop
      function animate() {
        rotation = (rotation + 1) % 360;
        document.getElementById("rotation").value = rotation;
        document.getElementById("rotationValue").textContent = rotation + "¬∞";
        draw3D();
        animationId = requestAnimationFrame(animate);
      }

      // Event listeners
      document
        .getElementById("kernelSigma")
        .addEventListener("input", function () {
          document.getElementById("kernelSigmaValue").textContent = this.value;
          draw3D();
        });

      document
        .getElementById("rotation")
        .addEventListener("input", function () {
          rotation = parseInt(this.value);
          document.getElementById("rotationValue").textContent =
            this.value + "¬∞";
          draw3D();
        });

      document
        .getElementById("animateBtn")
        .addEventListener("click", function () {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
            this.textContent = "üé¨ Auto Rotate 3D View";
          } else {
            animate();
            this.textContent = "‚è∏Ô∏è Stop Rotation";
          }
        });

      document
        .getElementById("showSeparationBtn")
        .addEventListener("click", function () {
          showPlane = !showPlane;
          this.textContent = showPlane
            ? "‚úÇÔ∏è Hide Separating Plane"
            : "‚úÇÔ∏è Show Separating Plane";
          draw3D();
        });

      document
        .getElementById("resetBtn")
        .addEventListener("click", function () {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
            document.getElementById("animateBtn").textContent =
              "üé¨ Auto Rotate 3D View";
          }
          rotation = 45;
          document.getElementById("rotation").value = 45;
          document.getElementById("rotationValue").textContent = "45¬∞";
          document.getElementById("kernelSigma").value = 40;
          document.getElementById("kernelSigmaValue").textContent = "40";
          showPlane = true;
          document.getElementById("showSeparationBtn").textContent =
            "‚úÇÔ∏è Hide Separating Plane";
          draw3D();
        });

      // Initialize
      draw2D();
      draw3D();
    </script>
  </body>
</html>
